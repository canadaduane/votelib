<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title></title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="date" content="" />
  <link rel="stylesheet" href="haskell.css" type="text/css" />
</head>
<body>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://www.cs.york.ac.uk/fp/darcs/hscolour/ --><title>Haskell code</title> <link type='text/css' rel='stylesheet' href='hscolour.css' /></head>
<body>
<h1>Virtual Round Robin Voting</h1>
<p
>This <a href="http://www.haskell.org">Haskell</a> code implements <a href="http://bolson.org/voting/VRRexplaination.pdf">virtual round robin voting</a>, minus the final decision function.</p
><h2>Imports</h2>
As a first step, we import the LinearAlgebra tools from the hmatrix library, in addition to the following helper functions:<ol>
<li>The ‘fromBool’ function turns False into 0 and True into 1, which we will need later.</li>
<li>The ‘elemIndex’ function returns the 0-based index of an element in a list (assuming it can be found in the list).</li>
</ol>

<pre> <span class='hs-keyword'>import</span> <span class='hs-conid'>Numeric</span><span class='hs-varop'>.</span><span class='hs-conid'>LinearAlgebra</span>
 <span class='hs-keyword'>import</span> <span class='hs-conid'>Foreign</span><span class='hs-varop'>.</span><span class='hs-conid'>Marshal</span><span class='hs-varop'>.</span><span class='hs-conid'>Utils</span> <span class='hs-layout'>(</span><span class='hs-varid'>fromBool</span><span class='hs-layout'>)</span>
 <span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>List</span> <span class='hs-layout'>(</span><span class='hs-varid'>elemIndex</span><span class='hs-layout'>)</span>
</pre>
<h2>Definitions</h2>
<p
>Next we define the list of contenders that our voters can choose from. The index of each contender matters; so, for example, “Let’s watch a movie” is the zero-th element, which we will use in a moment.</p
><pre> <span class='hs-varid'>contenders</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>String</span><span class='hs-keyglyph'>]</span>
 <span class='hs-varid'>contenders</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-str'>"Let's watch a movie"</span><span class='hs-layout'>,</span> <span class='hs-str'>"Let's build a fort"</span><span class='hs-layout'>,</span> <span class='hs-str'>"Let's go swimming"</span><span class='hs-keyglyph'>]</span>
</pre><p
>Here is where we pretend people voted. ‘v1’ is voter number 1, ‘v2’ is voter number 2, etc. Voter #1 prefers building a fort (contender item 1) to all other options, and prefers swimming (contender item 2) to watching a movie (contender item 0).</p
><pre> <span class='hs-varid'>v1</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span>
 <span class='hs-varid'>v1</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>1</span><span class='hs-layout'>,</span> <span class='hs-num'>2</span><span class='hs-layout'>,</span> <span class='hs-num'>0</span><span class='hs-keyglyph'>]</span> <span class='hs-comment'>-- Active person</span>
</pre><p
>Voter #2 prefers watching a movie (0) to building a fort (1), and building a fort (1) to swimming (2).</p
><pre> <span class='hs-varid'>v2</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span>
 <span class='hs-varid'>v2</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>0</span><span class='hs-layout'>,</span> <span class='hs-num'>1</span><span class='hs-layout'>,</span> <span class='hs-num'>2</span><span class='hs-keyglyph'>]</span> <span class='hs-comment'>-- Movie watcher</span>
</pre><p
>Voter #3 prefer building a fort (1) to watching a movie (0), and watching a movie (0) to swimming (2).</p
><pre> <span class='hs-varid'>v3</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span>
 <span class='hs-varid'>v3</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>1</span><span class='hs-layout'>,</span> <span class='hs-num'>0</span><span class='hs-layout'>,</span> <span class='hs-num'>2</span><span class='hs-keyglyph'>]</span> <span class='hs-comment'>-- Fort builder</span>
</pre><p
>Putting all the voting together, we get a list of ballots. Since each ballot above is a list of integers, a list of ballots is a list of lists of integers, denoted ‘[[Int]]’ in the type definition.</p
><pre> <span class='hs-varid'>ballots</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span>
 <span class='hs-varid'>ballots</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>v1</span><span class='hs-layout'>,</span> <span class='hs-varid'>v2</span><span class='hs-layout'>,</span> <span class='hs-varid'>v3</span><span class='hs-keyglyph'>]</span>
</pre><p
>Here’s the main part of our code: a function that takes an ordered list of integers and turns it into a preference matrix. The idea here is that we want a list like ‘[1, 0, 2]’ (as in the example of the Fort Builder vote, above) to turn into a matrix, like this:</p
><p
>[0 0 1]<br> [1 0 1]<br> [0 0 0]</p
><p
>We accomplish this using the ‘buildMatrix’ function which takes the number of rows and columns (3 in our case), and a ‘builder’ function. The builder function takes a (row, col) pair and for each row and column combination, produces the number value that should go in that spot. So in our example above, when the builder function gets row 0, column 0, it should return 0 (the upper-left corner of the matrix). But when it gets row 1, column 0, it should return 1. And so on down the list of rows and columns.</p
><pre> <span class='hs-varid'>ordered</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Matrix</span> <span class='hs-conid'>Double</span>
 <span class='hs-varid'>ordered</span> <span class='hs-varid'>prefs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>buildMatrix</span> <span class='hs-varid'>n</span> <span class='hs-varid'>n</span> <span class='hs-varid'>builder</span>
   <span class='hs-keyword'>where</span>
     <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>length</span> <span class='hs-varid'>prefs</span>
     <span class='hs-varid'>builder</span> <span class='hs-layout'>(</span><span class='hs-varid'>row</span><span class='hs-layout'>,</span> <span class='hs-varid'>col</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>row</span> <span class='hs-varop'>==</span> <span class='hs-varid'>col</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span> <span class='hs-comment'>-- zeros down the diagonal</span>
     <span class='hs-varid'>builder</span> <span class='hs-layout'>(</span><span class='hs-varid'>row</span><span class='hs-layout'>,</span> <span class='hs-varid'>col</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
       <span class='hs-keyword'>case</span> <span class='hs-varid'>elemIndex</span> <span class='hs-varid'>row</span> <span class='hs-varid'>prefs</span> <span class='hs-keyword'>of</span>
         <span class='hs-conid'>Just</span> <span class='hs-varid'>a</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>elemIndex</span> <span class='hs-varid'>col</span> <span class='hs-varid'>prefs</span> <span class='hs-keyword'>of</span>
                 <span class='hs-conid'>Just</span> <span class='hs-varid'>b</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>fromBool</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-varop'>&lt;</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
                 <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>error</span> <span class='hs-str'>"Couldn't find it"</span>
         <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>error</span> <span class='hs-str'>"Couldn't find it"</span>
</pre><p
>The tally function just adds up all of the matrices that we want to be part of the vote. We do this using the foldr function (a very common Haskell function), as well as the map function (another very common function).</p
><p
>The hmatrix library gives us a ‘&gt;&lt;’ operator (that kind of looks like an X) to create an n by m matrix. We use this operator to construct a 3 by 3 matrix of zeros called ‘zeroMatrix’.</p
><p
>You’ll also see the ‘buildMatrices’ function which takes the list of ballots and turns them into a list of matrices using the ‘ordered’ function we defined previously.</p
><pre> <span class='hs-varid'>tally</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-varop'>+</span><span class='hs-layout'>)</span> <span class='hs-varid'>zeroMatrix</span> <span class='hs-varid'>ballotMatrices</span>
   <span class='hs-keyword'>where</span> <span class='hs-varid'>zeroMatrix</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-num'>3</span><span class='hs-varop'>&gt;&lt;</span><span class='hs-num'>3</span> <span class='hs-varop'>$</span> <span class='hs-varid'>repeat</span> <span class='hs-num'>0</span><span class='hs-layout'>)</span>
         <span class='hs-varid'>ballotMatrices</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>ordered</span> <span class='hs-varid'>ballots</span>
</pre>
<h2>Main Function</h2>
<p
>Last but not least, we show our results of the tally as a 3x3 matrix. Haskell has a special function called ‘main’ that is the starting point recognized by the compiler. ‘putStrLn’ prints a string as the output of our program. The output of interest, in our case, is the ‘tally’ matrix shown as a string.</p
><pre> <span class='hs-varid'>main</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
   <span class='hs-varid'>putStrLn</span> <span class='hs-varop'>$</span> <span class='hs-varid'>show</span> <span class='hs-varid'>tally</span></pre></body>
</html>

</body>
</html>

